<!DOCTYPE html>
<html>
    <head>
        
            <title>Views: many-to-many relationships</title>
        
        <link rel="stylesheet" type="text/css" href="desktop.css" />
    </head>
    <body>
        <nav>
<ul>
<li>
<a href="/">Welcome</a>
</li>
<li>
<a href="what-is-couchdb.html">What is CouchDB?</a>
</li>
<li>
<a href="what-is-a-document.html">What is a document?</a>
</li>
<li>
<a href="http-api.html">HTTP API</a>
</li>
<li>
<a href="design_docs.html">Design documents</a>
</li>
<li>
<a href="shows.html">Show functions</a>
</li>
<li>
<a href="updates.html">Update functions</a>
</li>
<li>
<a href="filters.html">Filter functions</a>
</li>
<li>
<a href="views-map-only.html">Views: map-only</a>
</li>
<li>
<a href="views-many-many.html">Views: many-to-many relationships</a>
</li>
<li>
<a href="questions.html">Questions?</a>
</li>
</ul>
</nav>


        <article>
            
                
                    <h1>
                        Views: many-to-many relationships
                    </h1>
                

                
                    <p>
    Views let CouchDB databases do things that conventional wisdom says NoSQL databases can't do.
</p>

<p>
    For instance, consider a many-to-many relationship where we need fast lookups in either direction.
</p>

<p>
    Conventional wisdom says we need to store duplicate relationship data and keep it up-to-date manually.
</p>

<p>
    Let's see if CouchDB can make things easier for us.
</p>

<div class="column">
    <h2>
        Data set: authors &amp; books
    </h2>

    <p>
        Let's use the example of authors and books.
    </p>

    <p>
        An author may write many books, and a book may have many authors.
    </p>

    <p>
        So this is clearly a many-to-many relationship.
    </p>

    <p>
        Some basic author and book documents might look something like this:
    </p>

    <div class="subcolumn">
        <h3>
            Author documents
        </h3>

<pre>
{
    "_id": "pramod-j-sadalage",
    "name": "Pramod J. Sadalage",
    "author": true
}

{
    "_id": "martin-fowler",
    "name": "Martin Fowler",
    "author": true
}
</pre>

    </div>

    <div class="subcolumn">
        <h3>
            Book documents
        </h3>

<pre>
{
    "_id": "0321826620",
    "title": "NoSQL Distilled",
    "book": true,
}

{
    "_id": "0134757599",
    "title": "Refactoring: Improving...",
    "book": true,
}
</pre>

    </div>

    <p>
        How might we represent the relationships between these documents?
    </p>
</div>

<div class="column">
    <h2>
        Option A: duplicate relationship data
    </h2>

    <p>
        The classical approach is to include a list of books with each author and a list of authors with each book.
    </p>

    <div class="subcolumn">
        <h3>
            Author documents
        </h3>

<pre>
{
    "_id": "pramod-j-sadalage",
    "name": "Pramod J. Sadalage",
    "author": true,
<div class="highlight-code">    "books": [
        {
            "_id": "0321826620",
            "title": "NoSQL Distilled",
            "book": true,
        }
    ]
</div>}
</pre>

    </div>

    <div class="subcolumn">
        <h3>
            Book documents
        </h3>

<pre>
{
    "_id": "0321826620",
    "title": "NoSQL Distilled",
    "book": true,
<div class="highlight-code">    "authors": [
        {
            "_id": "pramod-j-sadalage",
            "name": "Pramod J. Sadalage",
            "author": true
        },
        {
            "_id": "martin-fowler",
            "name": "Martin Fowler",
            "author": true
        }
    ]
</div>}
</pre>

    </div>

    <p class="clear">
        In relational terms, we have essentially denormalized our database.
    </p>

    <p>
        This does give us all the information we need in a single query.
    </p>

    <p>
        If we typically want all of an author's books and all information about every author, then this might be the best approach.
    </p>

    <p>
        We do have to be very careful to keep both sets of documents updated &amp; consistent, without the benefit of transactions.
    </p>

    <p>
        On the other hand, if we typically want only a small portion of that data, then we're stuck reading a lot of extra information.
    </p>

    <p>
        When we update an author or book document, we're writing a lot of extra information, too.
    </p>
</div>

<div class="column">
    <h2>
        Option B: make a "junction table" document
    </h2>

    <p>
        What if we make a set of documents that act like rows in a junction table?
    </p>

    <p>
        I assume I'm not the only one in the class who's thought about this.
    </p>

    <p>
        Let's be clear: this is a really bad idea, but let's talk about why.
    </p>

    <div class="subcolumn">
        <h3>
            "Junction table" documents
        </h3>

<pre>
{
    "_id": "b2a/0321826620/pramod-j-sadalage",
    "book": "0321826620",
    "author": "pramod-j-sadalage",
}

{
    "_id": "b2a/0321826620/martin-fowler",
    "book": "0321826620",
    "author": "martin-fowler",
}
</pre>
    </div>

    <div class="subcolumn">
        <h3>
            Authors-to-books view
        </h3>

<pre>
function (doc) {
    if (doc._id.slice(0, 3) == 'b2a') {
        if (doc.book && doc.author) {
            emit(doc.author, doc.book);
        }
    }
}
</pre>
    </div>

    <p class="clear">
        Our document IDs are structured very carefully to make this scheme work:
    </p>

    <ul>
        <li>
            First, we use a common prefix, "b2a/", so that the documents will sit side-by-side in our sorted database.
        </li>
        <li>
            Next is each book's ID, so that our document collection will be sorted by book ID. 
        </li>
        <li>
            Finally, we list the author ID simply to make each document ID unique.
        </li>
    </ul>

    <p>
        Because our collection is sorted by book ID, we can use range queries to look up a book's authors.
    </p>

    <p>
        In order to look up an author's books quickly, we need our documents to be sorted by author. To solve this problem,<br />
        we can make a map-only view that emits &lt;author, book&gt; pairs.
    </p>

    <p>
        Now we can quickly query in either direction. Unfortunately, each book's authors are sorted alphabetically,<br />
        which will definitely anger a lot of authors. (It's possible to fix this, but there's a better way.)
    </p>

    <p>
        We also lose a lot of the clarity and simplity inherent in NoSQL data stores; we're going against the grain.
    </p>
</div>

<div class="column">
    <h2>
        Option C: make a "junction table" view
    </h2>

    <p>
        Let's try a more straightforward approach.
    </p>

    <p>
        We'll store a list of authors with each book, which makes sense and preserves the order of authors.
    </p>

    <div class="subcolumn">
        <h3>
            Author documents
        </h3>

<pre>
{
    "_id": "pramod-j-sadalage",
    "name": "Pramod J. Sadalage",
    "author": true
}

{
    "_id": "martin-fowler",
    "name": "Martin Fowler",
    "author": true
}
</pre>

    </div>

    <div class="subcolumn">
        <h3>
            Book documents
        </h3>

<pre>
{
    "_id": "0321826620",
    "title": "NoSQL Distilled",
    "book": true,
<div class="highlight-code">    "authors": [
        "pramod-j-sadalage",
        "martin-fowler"
    ]
</div>}

{
    "_id": "0134757599",
    "title": "Refactoring: Improving...",
    "book": true,
<div class="highlight-code">    "authors": [
        "martin-fowler"
    ]
</div>}
</pre>

    </div>

    <p class="clear">
        Any book's author list will be very short, so it's trivial to simply scan through the list as needed.<br />
    </p>

</div>

<div class="column">
    <h2>
        Indexing books' authors
    </h2>

    <p>
        Now we can use a simple, map-only view to index these author lists.
    </p>

    <p>
        For each author of each book, we emit &lt;author, book ID&gt;.
    </p>

    <p>
        This gives us a view, keyed by author ID, that lets us quickly look up an author's body of work.
    </p>

<pre>
GET /presentation/_design/loose_change/_view/<span class="highlight-code">authors_to_books</span>
</pre>

    <div class="subcolumn">
        <h2>
            Authors-to-books  view
        </h2>

<pre>
function (doc) {
    if (doc.book && doc.book === true 
        && doc.authors && isArray(doc.authors)) {
        doc.authors.forEach (function (author) {
            <span class="highlight-code">emit (author, doc._id);</span>
        });
    }
}
</pre>
        
    </div>

    <div class="subcolumn">
        <h3>
            Resulting view
        </h3>

<pre>
{
  "total_rows": 3,
  "offset": 0,
  "rows": [
    {
      "id": "0134757599",
      "key": "martin-fowler",
      "value": "0134757599"
    },
    {
      "id": "0321826620",
      "key": "martin-fowler",
      "value": "0321826620"
    },
    {
      "id": "0321826620",
      "key": "pramod-j-sadalage",
      "value": "0321826620"
    }
  ]
}
</pre>
    </div>
</div>

<div class="column">
    <h2>
        Querying an author's books
    </h2>

    <p>
        To see an author's books, we can ask the view for only keys matching an author ID.
    </p>

    <p>
        If we need the full document for each book, the view can give us that, too:
    </p>

<pre>
GET /presentation/_design/loose_change/_view/<span class="highlight-code">authors_to_books?key="martin-fowler"</span>

GET /presentation/_design/loose_change/_view/<span class="highlight-code">authors_to_books?key="martin-fowler"&amp;include_docs=true</span>
</pre>

    <div class="subcolumn">
        <h3>
            Martin Fowler's books
        </h3>
        
<pre>
{
  "total_rows": 3,
  "offset": 0,
  "rows": [
    {
      "id": "0134757599",
      "key": "martin-fowler",
      "value": "0134757599"
    },
    {
      "id": "0321826620",
      "key": "martin-fowler",
      "value": "0321826620"
    }
  ]
}
</pre>
    </div>

    <div class="subcolumn">
        <h3>
            Including book documents
        </h3>
        
<pre>
{
  "total_rows": 3,
  "offset": 0,
  "rows": [
    {
      "id": "0134757599",
      "key": "martin-fowler",
      "value": "0134757599",
      "doc": {
        ...
        "title": "Refactoring: Improving...",
        "book": true,
        ...
      }
    },
    {
      "id": "0321826620",
      "key": "martin-fowler",
      "value": "0321826620",
      "doc": {
        ...
        "title": "NoSQL Distilled",
        "book": true,
        ...
      }
    }
  ]
}
</pre>
    </div>

    <p class="clear">
        The best part is that our view is automatically updated whenever documents change, so we don't<br />
        have to worry about maintaining lots of denormalized data ourselves.
    </p>
</div>

                

                <div id="links">
<h2>
Links
</h2>
<ul>
<li>
<a href="http://docs.couchdb.org/en/stable/ddocs/ddocs.html#view-functions">Design Documents: View Functions</a>
</li>
<li>
<a href="http://docs.couchdb.org/en/stable/api/ddoc/views.html">API Reference: Views</a>
</li>
</ul>
</div>

            
        </article>
    </body>
</html>
